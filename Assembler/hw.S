// #08_1

 На стандартный ввод подаются два 32-битных знаковых целых числа. На стандартный вывод напечатайте сумму этих чисел. Гарантируется, что сумма представима 32-битным знаковым числом.
 
 Вывод числа завершайте переходом на новую строку.
 
 Программа будет компоноваться с libc. Точка входа в программу - main. Можете использовать вспомогательные функции ввода-вывода из файла simpleio.
 
         .text
         .global main
 main:
         call    readi32
         mov    %eax, %esi
         call   readi32
         addl   %esi, %eax
         call   writei32
         call   nl
         call   finish
 
//#08_2

 Определите (выделите память) пять 32-битных целых знаковых переменных A, B, C, D, R. Напишите функцию process, которая вычисляет R = A*B - C*D. Гарантируется, что результат и все промежуточные значения представимы 32-битным знаковым числом.
 
        .text
        .global process
 process:
        movl    C, %ecx
        movl    D, %eax
        imull   %ecx
        movl    %eax, %ecx
        movl    A, %edx
        movl    B, %eax
        imull   %edx
        subl    %ecx, %eax
        movl    %eax, R
        ret

         .data
         .global A, B, C, D, R
 A:    .int 0
 B:    .int 0
 C:    .int 0
 D:    .int 0
 R:    .int 0

//#08_3

 На стандартный ввод подаются одно 32-битное знаковое число. На стандартный вывод напечатайте последовательность целых чисел от заданного числа и до 0 в обратном порядке включительно. Если введенное число меньше 0, ничего не выводите.
 
 Вывод каждого числа завершайте переходом на новую строку.
 
 Программа будет компоноваться с libc. Точка входа в программу - main. Можете использовать вспомогательные функции ввода-вывода из файла simpleio.
 
 Examples
 
 Input
 
 5
 Output
 
 5
 4
 3
 2
 1
 0
        .text
        .global main
 main:
         call   readi32
         movl   %eax, %ebx
while:
         cmpl   $0, %eax
         jl     then
         call   writei32
         call   nl
         decl   %ebx
         movl   %ebx, %eax
         jmp    while
then:
         call   finish

//#08_4

 На стандартный ввод подается последовательность 32-битных знаковых целых чисел. Последовательность завершается признаком конца файла. На стандартный вывод напечатайте сумму всех чисел в последовательности. Если при прибавлении очередного считанного числа к промежуточному значению получается результат, не представимый 32-битным знаковым типом, напечатайте либо максимальное представимое значение (при сложении положительных чисел), либо минимальное представимое значение (при сложении отрицательных чисел) и завершите программу.
 
 Вывод числа завершайте переходом на новую строку.
 
 В программе допускается не более двух инструкций условного и безусловного перехода.
 
 Программа будет компоноваться с libc. Точка входа в программу - main. Можете использовать вспомогательные функции ввода-вывода из файла simpleio.
 
 Examples
 
 Input
 
 1 2 3 4 5
 Output
 
 15
 
        .text
        .global main
 main:
 while:
        call   readi32
        jc     ifEnd
        movl   %eax, %ebx
        addl   %eax, sum
        jo     overF
        jmp    while
 ifEnd:
        movl   sum, %eax
        call   writei32
        call   nl
        call   finish
 overF:
        movl   $2147483647, %eax
        cmpl   $0, %ebx
        jle    ifMin
        call   writei32
        call   nl
        call   finish
 ifMin:
        movl   $-2147483648, %eax
        call   writei32
        call   nl
        call   finish

        .data
 sum:   .int   0

//#08_5

 На стандартный ввод подается последовательность 32-битных знаковых целых чисел. Последовательность завершается признаком конца файла.
 
 На стандартный вывод напечатайте два числа: первое - это сумма всех четных чисел в данной последовательности, второе - сумма всех нечетных чисел. Гарантируется, что результат и все промежуточные значения представимы 32-битным знаковым числом.
 
 Вывод каждого числа завершайте переходом на новую строку.
 
 Программа будет компоноваться с libc. Точка входа в программу - main. Можете использовать вспомогательные функции ввода-вывода из файла simpleio.
 
 Examples
 
 Input
 
 1 2 3 4 5 6 7
 Output
 
 12
 16
 
        .text
        .global main
 main:
 while:
        call    readi32
        jc      end
        test    $1, %eax
        jz      ifEven
        addl    %eax, oddSum
        jmp     while
 ifEven:
        addl    %eax, evenSum
        jmp     while
 end:
        movl    evenSum, %eax
        call    writei32
        call    nl
        movl    oddSum, %eax
        call    writei32
        call    nl
        call    finish

        .data
 evenSum:   .int    0
 oddSum:    .int    0

//#09_1

 На языке ассемблера напишите подпрограмму print_fib. Она не принимает параметров и не возвращает результата. Данные подпрограмме передаются в глобальных 32-битных знаковых целых переменных A и B, определенных в других единицах компиляции.
 
 Попрограмма должна найти три числа Фибоначчи, которые следуют за числами, хранящимися в переменных A и B, и вывести их на стандартный поток вывода. Переменные A и B не должны модифицироваться. Для вывода чисел должен использоваться один вызов функции printf. Вывод чисел должен завершаться символом перевода строки.
 
 Подпрограмма print_fib должна соблюдать стандартные соглашения о вызовах. Должен использоваться стандартный пролог и эпилог функции.
 
 Результат операций и промежуточные значения представими 32-битным знаковым типом.
 
 Например, если в переменной A записано 10, а в переменной B записано 15, то подпрограмма должна вывести:
 
 25 40 65
 
        .text
        .global print_fib
print_fib:
        push %ebp
        movl %esp, %ebp

        mov A, %eax
        add B, %eax
        mov %eax, %ecx
        add B, %ecx
        mov %ecx, %edx
        add %eax, %edx
 
        push %edx
        push %ecx
        push %eax
        push $print
        call printf
        add $16, %esp

        pop %ebp
        ret
 
        .data
        .extern A
        .extern B
 print:    .asciz "%d %d %d\n"

//#09_2

 На языке ассемблера напишите функцию
 
 int mystrcmp(const char *str1, const char *str2);
 Функция должна реализовывать поведение стандартной функции strcmp. Функция возвращает значение 0, если две строки лексикографически равны, отрицательное значение, если первая строка лексикографически меньше второй, положительное значение, если первая строка лексикографически больше второй.
 
 Гарантируется, что параметры str1 и str2 не равны NULL.
 
 Подпрограмма должна соблюдать стандартные соглашения о вызовах. Подпрограмма должна использовать стандартные прологи и эпилоги. Для доступа к параметрам используйте регистр стекового кадра.
 

        .global mystrcmp
mystrcmp:
        push %ebp
        mov %esp, %ebp
        push %esi
        push %edi
        mov 8(%ebp), %esi
        mov 12(%ebp), %edi
while:
        movzb (%esi), %eax
        movzb (%edi), %edx
        inc %esi
        inc %edi
        sub %edx, %eax
        jnz end
        test %edx, %edx
        jnz while

end:    pop %edi
        pop %esi
        pop %ebp
        ret

//#09_3

 Напишите подпрограмму satsum, которая принимает два 32-битных беззнаковых целых числа и возвращает 32-битное целое беззнаковые число. Подпрограмма выполняет сложение с насыщением двух беззнаковых чисел. То есть, если сложение вызывает переполнение, результатом будет максимальное целое 32-битное беззнаковое число.
 
 Подпрограмма должна соблюдать стандартные соглашения о вызовах. Подпрограмма должна использовать стандартные прологи и эпилоги. Для доступа к параметрам используйте регистр стекового кадра.
 
        .text
        .global satsum
satsum:
        push %ebp
        mov %esp, %ebp

        mov 8(%ebp), %eax
        add 12(%ebp), %eax
        jnc end
        mov $0xFFFFFFFF, %eax

end:    mov %ebp, %esp
        pop %ebp
        ret
 

//#09_4

 На языке ассемблера напишите функцию process, решающую следующую задачу.
 
 На стандартном потоке ввода задается последовательность четверок целых чисел a1, b1, a2, b2. Числа представимы типом int. Числа разделяются пробельными символами. Гарантируется, что a1 ≤ b1 и a2 ≤ b2. Последовательность заканчивается с признаком конца файла.
 
 Числа a и b задают левый и правый концы отрезка [a,b) (левый конец отрезка входит в него, правый - нет). Таким образом каждая четверка целых чисел задает два отрезка.
 
 Для каждой пары отрезков, считанной из входного потока, найдите длину отрезка, являющегося пересечением двух отрезков. То есть четверка чисел во входном потоке данных рассматривается независимо от других четверок. На стандартный поток вывода напечатайте суммарную длину всех отрезков-пересечений.
 
 Не забывайте выводить символ перевода на новую строку в конце вывода.
 
 Все целые числа во входных данных и все промежуточные результаты вычислений представимы 32-битными знаковыми целыми числами.
 
 Функция должна соблюдать стандартные соглашения о вызовах. Чтение данных должно выполняться с помощью scanf (4 числа за один вызов), вывод результата должен выполняться с помощью printf. Функция должна использовать стандартные пролог и эпилог. Переменные для чтения из входного потока должны размещаться в стеке. Глобальные переменные запрещены.
 
 Examples
 
 Input
 
 10 20 15 25
 Output
 
 5
 
 .text
 .global process
 
 retMax:
 pushl %ebp
 movl %esp, %ebp
 movl 12(%ebp), %eax
 cmpl 8(%ebp), %eax
 jge pushMax
 movl 8(%ebp), %eax
 pushMax:
 leal (%ebp), %esp
 pop %ebp
 ret
 
 retMin:
 pushl %ebp
 movl %esp, %ebp
 movl 12(%ebp), %eax
 cmpl 8(%ebp), %eax
 jle pushMin
 movl 8(%ebp), %eax
 pushMin:
 leal (%ebp), %esp
 pop %ebp
 ret
 
 process:
 pushl %ebp
 movl %esp, %ebp
 push %esi
 push %edi
 push %ebx
 pushl $0
 
 while:
 subl $16, %esp
 movl %esp, %ebx
 leal 12(%ebx), %eax
 pushl %eax
 leal 8(%ebx), %eax
 pushl %eax
 leal 4(%ebx), %eax
 pushl %eax
 leal (%ebx), %eax
 pushl %eax
 pushl $scanstyle
 call scanf
 cmpl $4, %eax
 jnz EOF
 addl $20, %esp
 
 // calculate max of a1 a2
 pushl (%ebx)
 pushl 8(%ebx)
 call retMax
 movl %eax, %edi
 addl $8, %esp
 
 // calculate min of b1 b2
 pushl 4(%ebx)
 pushl 12(%ebx)
 call retMin
 movl %eax, %esi
 addl $8, %esp
 
 // calculate diff between min and max
 movl %esi, %eax
 subl %edi, %eax
 jge retDif
 movl $0, %eax
 
 retDif:
 addl %eax, -16(%ebp)
 jmp while
 
 EOF:
 pushl -16(%ebp)
 pushl $printstyle
 call printf
 addl $8, %esp
 leal -12(%ebp), %esp
 pop %edx
 pop %edi
 pop %esi
 pop %ebp
 ret
 
 
 .data
 scanstyle:    .asciz "%d %d %d %d"
 printstyle:    .asciz "%d\n"
